{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	"hashes": {
		"prefix": "hashes",
		"body": [
		  "",
		  "using namespace chrono;",
		  "typedef unsigned long long H; ",
		  "static H C;",
		  "static H L;",
		  "struct HashInterval {",
		  "    vector<H> ha, pw;",
		  "	HashInterval(string& str) : ha(str.size()+1), pw(ha) {",
		  "		pw[0] = 1;",
		  "		for(int i=0;i<str.size();i++)   ",
		  "            ha[i+1] = (ha[i] * L + str[i]-'a'+1)%C,",
		  "		    pw[i+1] = (pw[i] * L)%C;",
		  "	}",
		  "	H hashInterval(int a, int b){       // ",
		  "		return (ha[b] - ha[a] * pw[b - a]%C+C)%C;",
		  "	}",
		  "}; ",
		  "template<typename T>",
		  "bool isPrime(T N) {",
		  "	if(N<2)return false;",
		  "	if(N<4)return true;",
		  "	if(N%2==0 or N%3==0)return false;",
		  "	T curr=5;",
		  "	while(curr*curr<=N){",
		  "		if(N%curr==0)return false;",
		  "		curr+=2;",
		  "		if(N%curr==0)return false;",
		  "		curr+=4;",
		  "	}",
		  "	return true;",
		  "}",
		  "/*  USAGE!",
		  "    string t;",
		  "    cin>>t;",
		  "    precompH();",
		  "",
		  "	HashInterval alpha(t);      //computes hash for the entire string..",
		  "",
		  "    alpha.hashInterval(l,r);        // gives you the hash interval for this range!",
		  "*/",
		  "void precompH(){                //  [DONT FORGET TO USE THIS !!! -> CALLING ONCE IS FINE!]",
		  "    mt19937 rng(duration_cast<nanoseconds>(high_resolution_clock::now().time_since_epoch()).count());",
		  "    uniform_int_distribution<unsigned long long> distribution(1000000000,4000000000);",
		  "	uniform_int_distribution<unsigned long long> distribution2(31,200);",
		  "	C = distribution(rng);",
		  "	L = distribution2(rng);",
		  "    while(!isPrime(C))C++;",
		  "}"
		],
		"description": "generate hash for string"
	  },
	"lps": {
        "prefix": "lps",
        "body": [
            "vector<int> get_lps(string& s){",
            "\tint n=s.size();",
            "\tvector<int> lps(n,0);",
            "\tfor(int i=1,j=0;i<s.size();){",
            "\t\tif(s[i]==s[j])  lps[i++]=++j;",
            "\t\telse{",
            "\t\t\tif(j>0) j=lps[j-1];",
            "\t\t\telse i++;",
            "\t\t}",
            "\t}",
            "\treturn lps;",
            "}"
        ],
        "description": "lps"
    },
    "Unionfind": {
        "prefix": "UnionFind",
        "body": [
            "",
            "const int MX_SZ=1e5+5;",
            "int par[MX_SZ];",
            "int sz[MX_SZ];",
            "",
            "int getPar(int x){ return par[x]=par[x]==x?x:getPar(par[x]);}",
            "",
            "void setUnion(int x,int y){",
            "\tint px=getPar(x),py=getPar(y);",
            "\tif(px!=py){",
            "\t\tpar[px]=py;",
            "\t\tsz[py]+=sz[py];",
            "\t}",
            "}",
            ""
        ],
        "description": "UnionFind"
    },
    "primeSnip": {
        "prefix": "primeSnip",
		"body": [
			"const int SZ=5e6+5;",
			"int numFactors[SZ];     // the number of primes which are a divisor of i.",
			"int minPrime[SZ];       // the minimum prime which is a divisor of i",
			"vector<int> primes;",
			"void precomp(){",
			"    memset(numFactors,0,sizeof numFactors);",
			"    memset(minPrime,-1,sizeof minPrime);",
			"    minPrime[1]=1;",
			"    for(int i=2;i<SZ;i++){",
			"        if(minPrime[i]==-1){",
			"            primes.push_back(i);",
			"            for(int j=i;j<SZ;j+=i){",
			"                minPrime[j]=i;   ",
			"            }",
			"        }",
			"    }",
			"    for(int i=2;i<SZ;i++){",
			"        int div=i/minPrime[i];",
			"        numFactors[i]=numFactors[div]+(minPrime[div]!=minPrime[i]);",
			"    }",
			"}",
			"bool isPrime(int n){",
			"    return minPrime[n]==n;    // comment out this if not precomputed! ",
			"    for(int i=2;i*i<=n;i++){if(n%i==0)  return 0;}return 1;",
			"}",
			"",
			"bool valid(int n,set<int>& avail){",
			"    int div=minPrime[n];",
			"    while(div>1){",
			"        if(!avail.count(div))   return 0;",
			"        n/=div;",
			"        div=minPrime[n];",
			"    }",
			"    return 1;",
			"}"
		  ],
    },
	"math snippet": {
		"prefix": "mathSnip",
		"body": [
		  "// ========================================MATH UTIL BEGINS==============================================",
		  "//==================================== compute higher powers with mod ===================================",
		  "uint power(int x, int y, int p =  MOD)",
		  "{",
		  "    unsigned long long res = 1;",
		  "",
		  "    x = x % p;",
		  "    while (y > 0)",
		  "    {",
		  "",
		  "        if (y & 1)",
		  "            res = (res * x) % p;",
		  "",
		  "        y = y >> 1;",
		  "        x = (x * x) % p;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "// =============================================================================================================",
		  "",
		  "uint modInverse(int n, int p=MOD)       // using fermats little thm. [p needs to be prime which is mostly the case as mod value generally is 1e9+7]",
		  "{",
		  "    return power(n, p - 2, p);",
		  "}",
		  "// can also derive this using extended euclidean... however this has a much simpler code....",
		  "",
		  "",
		  "// =========================================Used to calculate nCr of higher values ===================================",
		  "uint nCr(int n, int r, int p=MOD)     // faster calculation.. ",
		  "{",
		  "    if (n < r)",
		  "        return 0;",
		  "",
		  "    if (r == 0)",
		  "        return 1;",
		  "        ",
		  "    vector<int> fac(n+1,0);",
		  "    fac[0] = 1;",
		  "    for (int i = 1; i <= n; i++)",
		  "        fac[i] = (fac[i - 1] * i) % p;",
		  "",
		  "    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;",
		  "}",
		  "// ==================================== MATH UTIL ENDS=======================================================//",
		  ""
		],
		"description": ""
	  },
	"SegmentTree": {
		"prefix": "segTreeSnip",
		"body": [
		  "class STree{        ",
		  "private:",
		  "",
		  "    // [IMPORTANT]  CHANGE this function as required. ",
		  "    int defaultVal=INT_MAX;",
		  "    vector<int> tree,lazy;",
		  "    int n;",
		  "    ",
		  "    // [IMPORTANT] CHANGE this function as required.",
		  "    void pushDown(int v,int tl, int tr){    // if your current node had some changes and it's there in the lazy vector i.e. ",
		  "    // lazy[v] that means they weren't propagated to it's children .... .",
		  "",
		  "",
		  "        // this block is responsible for adding the values to both the left and right children.",
		  "        // the limits of these children are from tl to tmid & tmid+1,tl",
		  "        int tmid=(tl+tr)>>1;",
		  "        // the below is an example for adding a value to all nodes in the range ",
		  "        // and utilising the tree for minimum in the range",
		  "        tree[v*2]+=lazy[v];",
		  "        tree[v*2+1]+=lazy[v];",
		  "        lazy[v*2]+=lazy[v];         // take a note that you made some changes that haven't been passed on to your children . ",
		  "        lazy[v*2+1]+=lazy[v];           ",
		  "",
		  "        //once the updates are pushed to the children the parent can get rid of the update!",
		  "        lazy[v]=0;  // my responsibility is completely I've told the changes to my children.. now it's their headache!!!!1  ",
		  "    }",
		  "",
		  "",
		  "    // [IMPORTANT] CHANGE this function as required.",
		  "    void combine(int v){  ",
		  "        tree[v]=min(tree[v<<1],tree[v<<1|1]);",
		  "    }",
		  "    ",
		  "    int query(int v, int tl, int tr, int l, int r) {      ",
		  "        if (tr <tl) return defaultVal;",
		  "        if(tl>r || tr<l)    return defaultVal;       // invalid indices tried!",
		  "        if (l <= tl && r >= tr) return tree[v];     // the current segment completely belongs to the answer",
		  "        int tm = (tl + tr)>>1;",
		  "        pushDown(v,tl,tr);",
		  "        combine(v);",
		  "",
		  "        // [IMPORTANT] CHANGE this code below as required.",
		  "        return min(query(v<<1, tl, tm, l, r)  , query(v<<1|1, tm+1, tr, l, r));",
		  "    }",
		  "    void buildTree(vector<int>& a,int tl, int tr,int v=1){  // builds up the tree starting from the root.",
		  "        if(tl>tr) return;",
		  "        if(tl==tr){",
		  "            tree[v]=a[tl];",
		  "            return;",
		  "        }",
		  "        int mid=(tl+tr)>>1;",
		  "        buildTree(a,tl,mid,v<<1);",
		  "        buildTree(a,mid+1,tr,v<<1|1);",
		  "        combine(v);",
		  "    }",
		  "    void update(int l,int r,int val,int v,int tl,int tr){",
		  "        if(tl>tr) return;",
		  "        if(tl>r || tr<l)  return;     //not in the current range",
		  "        ",
		  "        if(tl>=l && tr<=r){        // [IMPORTANT] CHANGE the code below as required.",
		  "        // if the subtree is completely inside the range then update the current node ... ",
		  "        // also make sure your children can get this info in the future if and when they need it ...",
		  "            tree[v]+=val;   // update the value! ",
		  "            lazy[v]+=val;   // this is just for reference for the children and not for the current node as your current node is already updated!   ",
		  "            return;         // return;",
		  "        }",
		  "        pushDown(v,tl,tr);          // notifying my children of the changes (if any! )",
		  "        int tmid=(tl+tr)>>1;",
		  "        update(l,r,val,v<<1,tl,tmid);",
		  "        update(l,r,val,v<<1|1,tmid+1,tr);",
		  "        combine(v);",
		  "    }",
		  "public:",
		  "    STree(vector<int>& vec){",
		  "        n=vec.size();",
		  "        tree.assign(n<<2,defaultVal);       // all nodes initially have default values ",
		  "        lazy.assign(n<<2,0);",
		  "        buildTree(vec,0,n-1);",
		  "    }",
		  "",
		  "    int query(int l,int r){             // query in the range l to r.",
		  "        return query(1,0,n-1,l,r);",
		  "    }",
		  "    void update(int idx,int val){       // this is overloaded for point updates",
		  "        update(idx,idx,val,1,0,n-1);",
		  "    }",
		  "    void update(int l,int r,int val){     ",
		  "        update(l,r,val,1,0,n-1);",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	"max segment tree": {
		"prefix": "mxSegmentSnip",
		"body": [
		  "        // ====================================start of the segment tree=========================================",
		  "class STreeMX{        ",
		  "private:",
		  "    int MN=INT_MIN;",
		  "    int MX=INT_MAX;",
		  "    vector<int> tree;",
		  "    int n;",
		  "    int getMx(int v, int tl, int tr, int l, int r) {      ",
		  "        if (tr <tl) return MN;",
		  "        if(l>tr || tl>r)    return MN;       // invalid indices tried!",
		  "        if (l <= tl && r >= tr) return tree[v];     // the current segment completely belongs to the answer",
		  "        ",
		  "        int tm = (tl + tr) / 2;",
		  "        return max(getMx(v*2, tl, tm, l, r)  , getMx(v*2+1, tm+1, tr, l, r));",
		  "    }",
		  "    void buildTree(vector<int>& a,int tl, int tr,int v=1){",
		  "        if(tl>tr) return;",
		  "        if(tl==tr){",
		  "            tree[v]=a[tl];",
		  "            return;",
		  "        }",
		  "",
		  "        int mid=(tl+tr)/2;",
		  "        buildTree(a,tl,mid,v*2);",
		  "        buildTree(a,mid+1,tr,v*2+1);",
		  "        tree[v]=max(tree[v*2],tree[v*2+1]);",
		  "    }",
		  "    void update(int idx,int val,int v,int tl,int tr){",
		  "        if(tl>tr) return;",
		  "        if(idx<tl || idx>tr)  return;     //not in the current range",
		  "        if(tl==tr){",
		  "            tree[v]=val;",
		  "            return;",
		  "        }",
		  "        int tmid=(tl+tr)/2;",
		  "        update(idx,val,v*2,tl,tmid);",
		  "        update(idx,val,v*2+1,tmid+1,tr);",
		  "        tree[v]=max(tree[v*2],tree[v*2+1]);",
		  "    }",
		  "public:",
		  "    STreeMX(int sz,vector<int>& vec){",
		  "        n=sz;",
		  "        tree.assign(sz*4,0);",
		  "        buildTree(vec,0,n-1);",
		  "    }",
		  "",
		  "    int getMx(int l,int r){",
		  "        return getMx(1,0,n-1,l,r);         // call the function!",
		  "    }",
		  "    void update(int idx,int val){     // v is the new value!",
		  "        update(idx,val,1,0,n-1);",
		  "    }",
		  "    void printTree(vector<int>& v){",
		  "        cout<<v<<\"\\n\";",
		  "    }",
		  "",
		  "};",
		  "// ========================================= Segment tree ends here====================================",
		  ""
		],
		"description": ""
	  },
	"basic template": {
		"prefix": "qa",
		"body": [
		  "#include \"bits/stdc++.h\"",
		  "#define int long long",
		  "#define uint unsigned long long",
		  "#define vi vector<int>",
		  "#define vvi vector<vi >",
		  "#define vb vector<bool>",
		  "#define vvb vector<vb >",
		  "#define fr(i,n) for(int i=0; i<(n); i++)",
		  "#define rep(i,a,n) for(int i=(a); i<=(n); i++)",
		  "#define nl cout<<\"\\n\"",
		  "#define dbg(var) cout<<#var<<\"=\"<<var<<\" \"",
		  "#define all(v) v.begin(),v.end()",
		  "#define srt(v)  sort(v.begin(),v.end())         // sort ",
		  "#define mxe(v)  *max_element(v.begin(),v.end())     // find max element in vector",
		  "#define mne(v)  *min_element(v.begin(),v.end())     // find min element in vector",
		  "#define unq(v)  v.resize(distance(v.begin(), unique(v.begin(), v.end())));",
		  "// make sure to sort before applying unique // else only consecutive duplicates would be removed ",
		  "#define bin(x,y)  bitset<y>(x) ",
		  "using namespace std;",
		  "int MOD=1e9+7;      // Hardcoded, directly change from here for functions!",
		  "",
		  "",
		  "",
		  "void modadd(int &a , int b) {a=((a%MOD)+(b%MOD))%MOD;}",
		  "void modsub(int &a , int b) {a=((a%MOD)-(b%MOD)+MOD)%MOD;}",
		  "void modmul(int &a , int b) {a=((a%MOD)*(b%MOD))%MOD;}",
		  "// ================================== take ip/op like vector,pairs directly!==================================",
		  "template<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }",
		  "template<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }",
		  "template<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }",
		  "template<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }",
		  "template<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }",
		  "// ===================================END Of the input module ==========================================",
		  "",
		  "",
		  "void solve(){",
		  "    int n=1,m=0;",
		  "    string s;",
		  "    cin>>n;",
		  "    vi v(n);",
		  "    cin>>v;$0",
		  "    ",
		  "}",
		  "",
		  "int32_t main()",
		  "{",
		  " ",
		  " ios_base::sync_with_stdio(false);",
		  " cin.tie(NULL);",
		  "",
		  "    int T = 1;",
		  "    cin >> T;",
		  "    while (T--)",
		  "    {",
		  "        solve();",
		  "    }",
		  "    return 0;",
		  "}",
		  "",
		  "    "
		],
		"description": ""
	  },
	  "gr-inp-wt": {
		"prefix": "gr-inp-Fwt",
		"body": [
		  "int e=${0};",
		  "vector<vector<pair<int,int>>> g(n+1);",
		  "for(int i=1;i<=e;i++){",
		  "  int u,v,wt; cin>>u>>v>>wt;",
		  "  g[u].push_back({v,wt});",
		  "  g[v].push_back({u,wt});",
		  "}"
		],
		"description": "graph input weight"
	},
	"gr-inp": {
		"prefix": "gr-inp",
		"body": [
		  "int e=${0};",
		  "vector<vector<int>> g(n+1);",
		  "for(int i=1;i<=e;i++){",
		  "  int u,v; cin>>u>>v;",
		  "  g[u].push_back(v);",
		  "  g[v].push_back(u);",
		  "}"
		],
		"description": "graph input"
	},
	"file_io": {
		"prefix": "file_io",
		"body": [
		  "void file_i_o(){",
		  "    freopen(\"./tests/test01.txt\", \"r\", stdin);",
		  "    freopen(\"./tests/output01.txt\", \"w\", stdout);",
		  "}"
		],
		"description": "for coding competetions"
	},
	"clock": {
		"prefix": "clock for TL",
		"body": [
		  "auto start = chrono::high_resolution_clock::now();",
		  "// code goes here",
		  "auto stop = chrono::high_resolution_clock::now();",
		  "auto duration = chrono::duration_cast<chrono::milliseconds>(stop - start);",
		  "cout << duration.count() << \" ms\\n\";",
		  ""
		],
		"description": "clock"
	},
	"segtree": {
		"prefix": "Default_segtree",
		"body": [
		  "template<class T, class U>",
		  "// T -> node, U->update.",
		  "struct Lsegtree{",
		  "    vector<T>st;",
		  "    vector<U>lazy;",
		  "    int n;",
		  "    T identity_element;",
		  "    U identity_update;",
		  "",
		  "    /*",
		  "        Definition of identity_element: the element I such that combine(x,I) = x",
		  "        for all x",
		  "",
		  "        Definition of identity_update: the element I such that apply(x,I) = x",
		  "        for all x        ",
		  "    */",
		  "",
		  "    Lsegtree(int n, T identity_element, U identity_update){",
		  "        this->n = n;",
		  "        this->identity_element = identity_element;",
		  "        this->identity_update = identity_update;",
		  "        st.assign(4*n,identity_element);",
		  "        lazy.assign(4*n, identity_update);",
		  "    }",
		  "",
		  "    T combine(T l, T r){",
		  "        // change this function as required.",
		  "        T ans = (l + r);",
		  "        return ans;",
		  "    }",
		  "",
		  "    void buildUtil(int v, int tl, int tr, vector<T>&a){",
		  "        if(tl == tr){",
		  "            st[v] = a[tl];",
		  "            return;",
		  "        }",
		  "        int tm = (tl + tr)>>1;",
		  "        buildUtil(2*v + 1, tl, tm,a);",
		  "        buildUtil(2*v + 2,tm+1,tr,a);",
		  "        st[v] = combine(st[2*v + 1], st[2*v + 2]);",
		  "    }",
		  "",
		  "    // change the following 2 functions, and you're more or less done.",
		  "    T apply(T curr, U upd, int tl, int tr){",
		  "        T ans = (tr-tl+1)*upd;",
		  "        // increment range by upd:",
		  "        // T ans = curr + (tr - tl + 1)*upd",
		  "        return ans;",
		  "    }",
		  "",
		  "    U combineUpdate(U old_upd, U new_upd, int tl, int tr){",
		  "        U ans = old_upd;",
		  "        ans=new_upd;",
		  "        return ans;",
		  "    }  ",
		  "",
		  "    void push_down(int v, int tl, int tr){",
		  "        //for the below line to work, make sure the \"==\" operator is defined for U.",
		  "        if(lazy[v] == identity_update)return;",
		  "        st[v] = apply(st[v], lazy[v], tl, tr);",
		  "        if(2*v + 1 <= 4*n){",
		  "            int tm = (tl + tr)>>1;",
		  "            lazy[2*v + 1] = combineUpdate(lazy[2*v+1], lazy[v], tl, tm);",
		  "            lazy[2*v + 2] = combineUpdate(lazy[2*v+2], lazy[v], tm+1,tr);            ",
		  "        }",
		  "        lazy[v] = identity_update;",
		  "    }",
		  "",
		  "    T queryUtil(int v, int tl, int tr, int l, int r){",
		  "        push_down(v,tl,tr);",
		  "        if(l > r)return identity_element;",
		  "        if(tr < l or tl > r){",
		  "            return identity_element;",
		  "        }",
		  "        if(l <= tl and r >= tr){",
		  "            return st[v];",
		  "        }",
		  "        int tm = (tl + tr)>>1;",
		  "        return combine(queryUtil(2*v+1,tl,tm,l,r), queryUtil(2*v+2,tm+1,tr,l,r));",
		  "    }",
		  " ",
		  "    void updateUtil(int v, int tl, int tr, int l, int r, U upd){",
		  "        push_down(v,tl,tr); ",
		  "        if(tr < l or tl > r)return;",
		  "        if(tl >=l and tr <=r){",
		  "            lazy[v] = combineUpdate(lazy[v],upd,tl,tr);",
		  "            push_down(v,tl,tr);",
		  "        } else{",
		  "            int tm = (tl + tr)>>1;",
		  "            updateUtil(2*v+1,tl,tm,l,r,upd);",
		  "            updateUtil(2*v+2,tm+1,tr,l,r,upd);",
		  "            st[v] = combine(st[2*v + 1], st[2*v+2]);",
		  "        }",
		  "    }",
		  "",
		  "    void build(vector<T>a){",
		  "        assert( (int)a.size() == n);",
		  "        buildUtil(0,0,n-1,a);",
		  "    }",
		  "",
		  "    T query(int l, int r){",
		  "        return queryUtil(0,0,n-1,l,r);",
		  "    }",
		  "",
		  "    void update(int l,int r, U upd){",
		  "        updateUtil(0,0,n-1,l,r,upd);",
		  "    }",
		  "};"
		],
		"description": "segtree"
	},
	"binary indexed tree": {
		"prefix": "fenwick",
		"body": [
		  "// 0-indexed BIT (binary indexed tree / Fenwick tree) (i : [0, len))",
		  "template <class T>",
		  "struct BIT{",
		  "    int n;",
		  "    vector<T> data;",
		  "    BIT(int len = 0) : n(len), data(len) {}",
		  "    void reset() { fill(data.begin(), data.end(), T(0)); }",
		  "    void add(int pos, T v){ ",
		  "        // a[pos] += v",
		  "        pos++;",
		  "        while (pos > 0 and pos <= n)",
		  "            data[pos - 1] += v, pos += pos & -pos;",
		  "    }",
		  "    T sum(int k) const{ ",
		  "        // a[0] + ... + a[k - 1]",
		  "        T res = 0;",
		  "        while (k > 0)",
		  "            res += data[k - 1], k -= k & -k;",
		  "        return res;",
		  "    }",
		  "",
		  "    T sum(int l, int r) const { return sum(r) - sum(l); } // a[l] + ... + a[r - 1]",
		  "    // dbg functions",
		  "    template <class OStream>",
		  "    friend OStream &operator<<(OStream &os, const BIT &bit){",
		  "        T prv = 0;",
		  "        os << '[';",
		  "        for (int i = 1; i <= bit.n; i++){",
		  "            T now = bit.sum(i);",
		  "            os << now - prv << ',', prv = now;",
		  "        }",
		  "        return os << ']';",
		  "    }",
		  "};"
		],
		"description": "binary indexed tree"
	},
	"trie": {
		"prefix": "trie",
		"body": [
		  "struct Trie{",
		  "    struct node{",
		  "        node* next[10];",
		  "        node(){",
		  "            for(int i=0;i<10;i++) next[i]=NULL;",
		  "        }",
		  "    };",
		  " ",
		  "    node root;",
		  " ",
		  "    void add(vector<int>&val){",
		  "        node* temp=&root;",
		  "        for(auto ele : val){",
		  "            if(temp->next[ele]==NULL) temp->next[ele]=new node();",
		  "            temp=temp->next[ele];",
		  "        }",
		  "    }",
		  " ",
		  "    int query(vector<int>&val){",
		  "        node* temp=&root;",
		  "        int ans=0;",
		  "        for(auto ele : val){",
		  "            if(temp->next[ele]==NULL) break;",
		  "            ans++;",
		  "            temp=temp->next[ele];",
		  "        }",
		  "        return ans;",
		  "    }",
		  "};",
		  ""
		],
		"description": "trie"
	},
	"pbds": {
		"prefix": "pbds",
		"body": [
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "// pbds = find_by_value(), order_of_key()",
		  "// find_by_order(k)  returns iterator to kth element starting from 0;",
		  "// order_of_key(k) returns count of elements strictly smaller than k;",
		  "template<class T> using minheap = priority_queue<T,vector<T>,greater<T> >; ",
		  "template<class T> using ordered_set = tree<T, null_type,less<T>, rb_tree_tag, tree_order_statistics_node_update> ;",
		  "template<class key, class value, class cmp = std::less<key>> using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;"
		],
		"description": "pbds"
	},
	"xor-basis ======NEED to learn this as well!": {
		"prefix": "xor-basis",
		"body": [
		  "struct XorBasis{",
		  "    private:",
		  "    vector<int> basis;",
		  "    int lg;",
		  "    int sz = 0;",
		  "",
		  "    public:",
		  "    XorBasis(int lg) : lg(lg){",
		  "        basis.resize(lg);",
		  "    }",
		  "    void add(int x){",
		  "        if(x >= (1ll<<lg)) return;",
		  "        for(int i=0;i<lg;i++){",
		  "            if(~x&(1ll<<i)) continue;",
		  "            if(!basis[i]){",
		  "                basis[i] = x;",
		  "                ++sz;",
		  "            }",
		  "            x^=basis[i];",
		  "        }",
		  "    }",
		  "    bool contains(int x){",
		  "        for(int i=0;i<lg;i++){",
		  "            if(~x&(1ll<<i)) continue;",
		  "            if(!basis[i]){",
		  "                return false;",
		  "            }",
		  "            x^=basis[i];",
		  "        }",
		  "        return true;",
		  "    }",
		  "    int size(){",
		  "        return sz;",
		  "    }",
		  "    const vector<int>::iterator begin(){",
		  "        return basis.begin();",
		  "    }",
		  "    const vector<int>::iterator end(){",
		  "        return basis.end();",
		  "    }",
		  "};",
		  ""
		],
		"description": "xor-basis"
	},
	"linear diophantine ============= NO IDEA why": {
		"prefix": "diophantine",
		"body": [
		  "long long gcd(long long a, long long b, long long &x, long long &y) {",
		  "  if (a == 0) {",
		  "    x = 0;",
		  "    y = 1;",
		  "    return b;",
		  "  }",
		  "  long long x1, y1;",
		  "  long long d = gcd(b % a, a, x1, y1);",
		  "  x = y1 - (b / a) * x1;",
		  "  y = x1;",
		  "  return d;",
		  "}",
		  "",
		  "bool find_any_solution(long long a, long long b, long long c, long long &x0,",
		  "    long long &y0, long long &g) {",
		  "  g = gcd(abs(a), abs(b), x0, y0);",
		  "  if (c % g) {",
		  "    return false;",
		  "  }",
		  "",
		  "  x0 *= c / g;",
		  "  y0 *= c / g;",
		  "  if (a < 0) x0 = -x0;",
		  "  if (b < 0) y0 = -y0;",
		  "  return true;",
		  "}",
		  "",
		  "void shift_solution(long long &x, long long &y, long long a, long long b,",
		  "    long long cnt) {",
		  "  x += cnt * b;",
		  "  y -= cnt * a;",
		  "}",
		  "",
		  "long long find_all_solutions(long long a, long long b, long long c,",
		  "    long long minx, long long maxx, long long miny,",
		  "    long long maxy) {",
		  "  long long x, y, g;",
		  "  if (!find_any_solution(a, b, c, x, y, g)) return 0;",
		  "  a /= g;",
		  "  b /= g;",
		  "",
		  "  long long sign_a = a > 0 ? +1 : -1;",
		  "  long long sign_b = b > 0 ? +1 : -1;",
		  "",
		  "  shift_solution(x, y, a, b, (minx - x) / b);",
		  "  if (x < minx) shift_solution(x, y, a, b, sign_b);",
		  "  if (x > maxx) return 0;",
		  "  long long lx1 = x;",
		  "",
		  "  shift_solution(x, y, a, b, (maxx - x) / b);",
		  "  if (x > maxx) shift_solution(x, y, a, b, -sign_b);",
		  "  long long rx1 = x;",
		  "",
		  "  shift_solution(x, y, a, b, -(miny - y) / a);",
		  "  if (y < miny) shift_solution(x, y, a, b, -sign_a);",
		  "  if (y > maxy) return 0;",
		  "  long long lx2 = x;",
		  "",
		  "  shift_solution(x, y, a, b, -(maxy - y) / a);",
		  "  if (y > maxy) shift_solution(x, y, a, b, sign_a);",
		  "  long long rx2 = x;",
		  "",
		  "  if (lx2 > rx2) swap(lx2, rx2);",
		  "  long long lx = max(lx1, lx2);",
		  "  long long rx = min(rx1, rx2);",
		  "",
		  "  if (lx > rx) return 0;",
		  "  return (rx - lx) / abs(b) + 1;",
		  "}",
		  ""
		],
		"description": "linear diophantine"
	},
	"crt ============= learn how to use": {
		"prefix": "crt",
		"body": [
		  "/**",
		  " * Chinese remainder theorem.",
		  " * Find z such that  z % x[i] = a[i] for all i.",
		  " * */",
		  "long long crt(vector<long long> &a, vector<long long> &x) {",
		  "  long long z = 0;",
		  "  long long n = 1;",
		  "  for (int i = 0; i < x.size(); ++i)",
		  "    n *= x[i];",
		  "",
		  "  for (int i = 0; i < a.size(); ++i) {",
		  "    long long tmp = (a[i] * (n / x[i])) % n;",
		  "    tmp = (tmp * mod_inv(n / x[i], x[i])) % n;",
		  "    z = (z + tmp) % n;",
		  "  }",
		  "",
		  "  return (z + n) % n;",
		  "}"
		],
		"description": "crt"
	},
	"totient-seive ========what": {
		"prefix": "totient-seive",
		"body": [
		  "  for (int i = 1; i < MN; i++)",
		  "    phi[i] = i;",
		  "",
		  "  for (int i = 1; i < MN; i++)",
		  "    if (!sieve[i]) // is prime",
		  "      for (int j = i; j < MN; j += i)",
		  "        phi[j] -= phi[j] / i;",
		  ""
		],
		"description": "totient-seive"
	},
	"totient ==============what": {
		"prefix": "totient",
		"body": [
		  "long long totient(long long n) {",
		  "  if (n == 1) return 0;",
		  "  long long ans = n;",
		  "  for (int i = 0; primes[i] * primes[i] <= n; ++i) {",
		  "    if ((n % primes[i]) == 0) {",
		  "      while ((n % primes[i]) == 0) n /= primes[i];",
		  "      ans -= ans / primes[i];",
		  "    }",
		  "  }",
		  "  if (n > 1) {",
		  "    ans -= ans / n;",
		  "  }",
		  "  return ans;",
		  "}"
		],
		"description": "totient"
	},
	"log   =============learn how to use": {
		"prefix": "log",
		"body": [
		  "// Computes x which a ^ x = b mod n.",
		  "",
		  "long long d_log(long long a, long long b, long long n) {",
		  "  long long m = ceil(sqrt(n));",
		  "  long long aj = 1;",
		  "  map<long long, long long> M;",
		  "  for (int i = 0; i < m; ++i) {",
		  "    if (!M.count(aj))",
		  "      M[aj] = i;",
		  "    aj = (aj * a) % n;",
		  "  }",
		  "",
		  "  long long coef = mod_pow(a, n - 2, n);",
		  "  coef = mod_pow(coef, m, n);",
		  "  // coef =  a ^ (-m)",
		  "  long long gamma = b;",
		  "  for (int i = 0; i < m; ++i) {",
		  "    if (M.count(gamma)) {",
		  "      return i * m + M[gamma];",
		  "    } else {",
		  "      gamma = (gamma * coef) % n;",
		  "    }",
		  "  }",
		  "  return -1;",
		  "}"
		],
		"description": "log"
	},
	"matrix": {
		"prefix": "matrix",
		"body": [
		  "const int MN  = 111;",
		  "const int mod = 10000;",
		  "",
		  "struct matrix {",
		  "  int r, c;",
		  "  int m[MN][MN];",
		  "",
		  "  matrix (int _r, int _c) : r (_r), c (_c) {",
		  "    memset(m, 0, sizeof m);",
		  "  }",
		  "",
		  "  void print() {",
		  "    for (int i = 0; i < r; ++i) {",
		  "      for (int j = 0; j < c; ++j)",
		  "        cout << m[i][j] << \" \";",
		  "      cout << endl;",
		  "    }",
		  "  }",
		  "",
		  "  int x[MN][MN];",
		  "  matrix & operator *= (const matrix &o) {",
		  "    memset(x, 0, sizeof x);",
		  "    for (int i = 0; i < r; ++i)",
		  "      for (int k = 0; k < c; ++k)",
		  "        if (m[i][k] != 0)",
		  "          for (int j = 0; j < c; ++j) {",
		  "            x[i][j] = (x[i][j] +  ((m[i][k] * o.m[k][j]) % mod) ) % mod;",
		  "          }",
		  "    memcpy(m, x, sizeof(m));",
		  "    return *this;",
		  "  }",
		  "};",
		  "",
		  "void matrix_pow(matrix b, long long e, matrix &res) {",
		  "  memset(res.m, 0, sizeof res.m);",
		  "  for (int i = 0; i < b.r; ++i)",
		  "    res.m[i][i] = 1;",
		  "",
		  "  if (e == 0) return;",
		  "  while (true) {",
		  "    if (e & 1) res *= b;",
		  "    if ((e >>= 1) == 0) break;",
		  "    b *= b;",
		  "  }",
		  "}"
		],
		"description": "matrix"
	},
	
	"power_in_fac ====need to check usecase": {
		"prefix": "highest_exponent",
		"body": [
		  "int highest_exponent(int p, const int &n){",
		  "  int ans = 0;",
		  "  int t = p;",
		  "  while(t <= n){",
		  "    ans += n/t;",
		  "    t*=p;",
		  "  }",
		  "  return ans;",
		  "}"
		],
		"description": "power_in_fac"
	},
	"freq-map  ===cool!": {
		"prefix": "freq-map",
		"body": [
		  "map<int, int> m;",
		  "for(int i=0; i<n;i++){",
		  "  if(m.find(a[i])==m.end()) m[a[i]]=1;",
		  "  else m[a[i]]++;",
		  "}"
		],
		"description": "freq-map"
	},
	"two-sat (kosaraju)  =========see where and when to use! --> description has usecases!": {
		"prefix": "two-sat (kosaraju)",
		"body": [
		  "/**",
		  " *  Given a set of clauses (a1 v a2)^(a2 v ¬a3)....",
		  " *  this algorithm find a solution to it set of clauses.",
		  " *  test: http://lightoj.com/volume_showproblem.php?problem=1251",
		  " **/",
		  "",
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "#define MAX 100000",
		  "#define endl '\\n'",
		  "",
		  "vector<int> G[MAX];",
		  "vector<int> GT[MAX];",
		  "vector<int> Ftime;",
		  "vector<vector<int> > SCC;",
		  "bool visited[MAX];",
		  "int n;",
		  "",
		  "",
		  "void dfs1(int n){",
		  "  visited[n] = 1;",
		  "",
		  "  for (int i = 0; i < G[n].size(); ++i) {",
		  "    int curr = G[n][i];",
		  "    if (visited[curr]) continue;",
		  "    dfs1(curr);",
		  "  }",
		  "",
		  "  Ftime.push_back(n);",
		  "}",
		  "",
		  "void dfs2(int n, vector<int> &scc) {",
		  "  visited[n] = 1;",
		  "  scc.push_back(n);",
		  "",
		  "  for (int i = 0;i < GT[n].size(); ++i) {",
		  "    int curr = GT[n][i];",
		  "    if (visited[curr]) continue;",
		  "    dfs2(curr, scc);",
		  "  }",
		  "}",
		  "",
		  "",
		  "void kosaraju() {",
		  "  memset(visited, 0, sizeof visited);",
		  "",
		  "  for (int i = 0; i < 2 * n ; ++i) {",
		  "    if (!visited[i]) dfs1(i);",
		  "  }",
		  "",
		  "  memset(visited, 0, sizeof visited);",
		  "  for (int i = Ftime.size() - 1; i >= 0; i--) {",
		  "    if (visited[Ftime[i]]) continue;",
		  "    vector<int> _scc;",
		  "    dfs2(Ftime[i],_scc);",
		  "    SCC.push_back(_scc);",
		  "  }",
		  "}",
		  "",
		  "/**",
		  " * After having the SCC, we must  traverse each scc, if in one SCC are -b y b, there is not a solution.",
		  " * Otherwise we  build a solution, making the first \"node\" that we find truth and its complement false.",
		  " **/",
		  "",
		  "",
		  "bool two_sat(vector<int> &val) {",
		  "  kosaraju();",
		  "  for (int i = 0; i < SCC.size(); ++i) {",
		  "    vector<bool> tmpvisited(2 * n, false);",
		  "    for (int j = 0; j < SCC[i].size(); ++j) {",
		  "      if (tmpvisited[SCC[i][j] ^ 1]) return 0;",
		  "      if (val[SCC[i][j]] != -1) continue;",
		  "      else {",
		  "        val[SCC[i][j]] = 0;",
		  "        val[SCC[i][j] ^ 1] = 1;",
		  "      }",
		  "      tmpvisited[SCC[i][j]] = 1;",
		  "    }",
		  "  }",
		  "  return 1;",
		  "}",
		  "",
		  "// Example of use",
		  "",
		  "int main() {",
		  "",
		  "  int m, u, v, nc = 0, t; cin >> t;",
		  "  // n = \"nodes\" number, m = clauses number",
		  "",
		  "  while (t--) {",
		  "    cin >> m >> n;",
		  "    Ftime.clear();",
		  "    SCC.clear();",
		  "    for (int i = 0; i < 2 * n; ++i) {",
		  "      G[i].clear();",
		  "      GT[i].clear();",
		  "    }",
		  "",
		  "    // (a1 v a2) = (¬a1 -> a2) = (¬a2 -> a1)",
		  "    for (int i = 0; i < m ; ++i) {",
		  "      cin >> u >> v;",
		  "      int t1 = abs(u) - 1;",
		  "      int t2 = abs(v) - 1;",
		  "      int p = t1 * 2 + ((u < 0)? 1 : 0);",
		  "      int q = t2 * 2 + ((v < 0)? 1 : 0);",
		  "      G[p ^ 1].push_back(q);",
		  "      G[q ^ 1].push_back(p);",
		  "      GT[p].push_back(q ^ 1);",
		  "      GT[q].push_back(p ^ 1);",
		  "    }",
		  "",
		  "    vector<int> val(2 * n, -1);",
		  "    cout << \"Case \" << ++nc <<\": \";",
		  "    if (two_sat(val)) {",
		  "      cout << \"Yes\" << endl;",
		  "      vector<int> sol;",
		  "      for (int i = 0; i < 2 * n; ++i)",
		  "        if (i % 2 == 0 and val[i] == 1)",
		  "          sol.push_back(i / 2 + 1);",
		  "      cout << sol.size() ;",
		  "",
		  "      for (int i = 0; i < sol.size(); ++i) {",
		  "        cout << \" \" << sol[i];",
		  "      }",
		  "      cout << endl;",
		  "    } else {",
		  "      cout << \"No\" << endl;",
		  "    }",
		  "  }",
		  "  return 0;",
		  "}"
		],
		"description": "two-sat (kosaraju)"
	},
	"pq   ============cool this can be handy!": {
		"prefix": "pq",
		"body": [
		  "priority_queue<int> pq;",
		  "priority_queue<int, vector<int>, greater<>> pq;"
		],
		"description": "pq"
	},
	"binsearch": {
		"prefix": "binsearch",
		"body": [
		  "int lo = 0, hi = 4e18,res=hi;",
		  "while(lo<=hi) {",
		  "    int mid = lo + ((hi-lo) >> 1);",
		  "    auto check = [&](int mid) {",
		  "      return (/*condition here*/);",
		  "    };",
		  "    if(check(mid)){",
		  "        res=mid;",
		  "        hi = mid-1;",
		  "    }",
		  "    else {",
		  "        lo = mid+1;",
		  "    }",
		  "}"
		],
		"description": "binsearch"
	},
	"fac": {
		"prefix": "fac",
		"body": [
		  "int fac[maxn];",
		  "int inv[maxn];",
		  "fac[1] = inv[1] = 1;",
		  "for (int i=2; i<maxn; i++){",
		  "  fac[i] = (fac[i-1] * i)%mod;",
		  "  inv[i] = power(fac[i], mod - 2);",
		  "}",
		  ""
		],
		"description": "fac"
	},
	"combination": {
		"prefix": "combination",
		"body": [
		  "int C(int n, int r){",
		  "    int v = (fac[n] * inv[r])%mod;",
		  "    v = (v * inv[n-r])%mod;",
		  "    ",
		  "    return v;",
		  "}",
		  ""
		],
		"description": "combination"
	},
	"combination-non-mod": {
		"prefix": "combination-non-mod",
		"body": [
		  "vector<vector<int>> dp(n+1, vector<int> (k+1));",
		  "int binomalCoeff(int n, int k){",
		  "    for (int i=0; i<=n; i++){",
		  "        for (int j=0; j<=k; j++){",
		  "             if (!j || j == i) dp[i][j] = 1;",
		  "             // binomial coefficient approach",
		  "             else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];",
		  "         }",
		  "     }",
		  "     return dp[n][k];",
		  "}"
		],
		"description": "combination-non-mod"
	},
	"factorization": {
		"prefix": "factorization",
		"body": [
		  "void printFactors(int n) { ",
		  "    for (int i=1; i * i<=n; i++){} ",
		  "        if (n%i == 0) { ",
		  "            if (n/i == i) cout << i << \" \"; ",
		  "            else cout << i << \" \" << n/i << \" \"; ",
		  "        } ",
		  "    }",
		  "    cout << \"\\n\";",
		  "} ",
		  "",
		  "void printPrimeFactors(int n){",
		  " set<int> f;",
		  " for (int i = 2; i*i <= n; i++){",
		  "     while (n % i == 0){",
		  "         f.insert(i);",
		  "         n /= i;",
		  "      }",
		  " }",
		  " for (auto &i : f){",
		  "     cout << i << \" \";",
		  " }",
		  " cout << \"\\n\";",
		  "}",
		  ""
		],
		"description": "factorization"
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
		  "class DSU {",
		  "private:",
		  "    vector<int> parent, size;",
		  "public:",
		  "    DSU(int n) {",
		  "        parent = vector<int>(n);",
		  "        size = vector<int>(n, 1);",
		  "        iota(begin(parent), end(parent), 0);",
		  "    }",
		  "    ",
		  "    int getParent(int x) {",
		  "        if (parent[x] == x) return x;",
		  "        return parent[x] = getParent(parent[x]);",
		  "    }",
		  "",
		  "    void join(int x, int y) {",
		  "        x = getParent(x);",
		  "        y = getParent(y);",
		  "        if (size[x] > size[y])",
		  "            swap(x, y);",
		  "        if (x == y) return;",
		  "        parent[x] = y;",
		  "        size[y] += size[x];",
		  "    }",
		  "",
		  "    int getSize(int x) {",
		  "        return size[x] = size[getParent(x)];",
		  "    }",
		  "};"
		],
		"description": "DSU"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
		  "auto kruskalMST(vector<Edge> &edges, int V){",
		  "    int cost = 0;",
		  "    DSU dsu(V);",
		  "    sort(begin(edges), end(edges));",
		  "    vector<Edge> tree;",
		  "    for (const auto &[u, v, w] : edges){",
		  "        if (dsu.getParent(u) != dsu.getParent(v)) {",
		  "            cost += w;",
		  "            tree.emplace_back(u, v, w);",
		  "            dsu.join(u, v);",
		  "        }",
		  "    }",
		  "    return make_pair(tree, cost);",
		  "}",
		  ""
		],
		"description": "kruskal"
	},
	"kosaraju": {
		"prefix": "kosaraju",
		"body": [
		  "class Graph {",
		  " int V;",
		  " vector<int> *adj;",
		  "",
		  " void fillOrder(int v, bool visited[], stack<int> &s);",
		  "",
		  " void dfsUtil(int v, bool visited[]);",
		  "",
		  "public:",
		  " Graph(int V) : V(V)",
		  " {",
		  "   adj = new vector<int>[V];",
		  " }",
		  " ~Graph()",
		  " {",
		  "    delete[] adj;",
		  " }",
		  "",
		  " void addEdge(int v, int w);",
		  "",
		  " void printSCCs();",
		  "",
		  " Graph getTranspose();",
		  "};",
		  "",
		  "void Graph::dfsUtil(int v, bool visited[]) {",
		  " visited[v] = true;",
		  " cout << v <<  \" \";",
		  " for (auto &it : adj[v])",
		  "     if (!visited[it])",
		  "        dfsUtil(it, visited);",
		  "}",
		  "",
		  "Graph Graph::getTranspose() {",
		  " Graph g(V);",
		  " for (int i = 0; i < V; i++) {",
		  "     for (auto &it : adj[i])",
		  "         g.adj[it].push_back(i);",
		  " }",
		  " return g;",
		  "}",
		  "",
		  "void Graph::addEdge(int v, int w) {",
		  " adj[v].push_back(w);",
		  "}",
		  "",
		  "void Graph::fillOrder(int v, bool visited[], stack<int> &s) {",
		  " visited[v] = true;",
		  " for (auto &it : adj[v])",
		  "     if (!visited[it])",
		  "         fillOrder(it, visited, s);",
		  " s.push(v);",
		  "}",
		  "",
		  "void Graph::printSCCs() {",
		  " stack<int> s;",
		  " bool visited[V] = {0};",
		  " for (int i = 0; i < V; i++)",
		  "      if (!visited[i])",
		  "        fillOrder(i, visited, s);",
		  "",
		  " Graph gr = getTranspose();",
		  " for (int i = 0; i < V; i++)",
		  "     visited[i] = false;",
		  "",
		  " while (!s.empty()) {",
		  "     int v = s.top();",
		  "     s.pop();",
		  "     if (!visited[v]){",
		  "        gr.dfsUtil(v, visited);",
		  "        cout << \"\\n\";",
		  "     }",
		  " }",
		  "}"
		],
		"description": "kosaraju"
	},
	"LCA path satisfying some condition": {
		"prefix": "lca",
		"body": [
		  "constexpr int N = 200005; // No. of vertices",
		  "constexpr int L = 20; // ceil(logN / log2) + 1",
		  "",
		  "// Vertices from 1 to N.",
		  "vector<int> adj[N + 1];",
		  "int up[N + 1][L];",
		  "int level[N + 1];",
		  "",
		  "void dfs(int u, int prev = 0){",
		  " up[u][0] = prev;",
		  " for (auto &v : adj[u]){",
		  "     if (v == prev) continue;",
		  "",
		  "     level[v] = level[u] + 1;",
		  "     dfs(v, u);",
		  " }",
		  "}",
		  "",
		  "void binaryLift(){",
		  " dfs(1);",
		  " for (int i = 1; i < L; i++)",
		  "     for (int j = 1; j <= N; j++)",
		  "          up[j][i] = up[up[j][i - 1]][i - 1];",
		  "}",
		  "",
		  "int LCA(int a, int b){",
		  " if (level[a] > level[b])",
		  "     swap(a, b);",
		  "",
		  " int diff = level[b] - level[a];",
		  " for (int i = 0; i < L; i++){",
		  "     if ((diff & (1 << i)))",
		  "         b = up[b][i];",
		  " }",
		  "",
		  " if (a == b) return a;",
		  "",
		  " for (int i = L - 1; i >= 0; i--){",
		  "     if (up[a][i] != up[b][i]){",
		  "         a = up[a][i];",
		  "         b = up[b][i];",
		  "     }",
		  " }",
		  " return up[a][0];",
		  "}",
		  "",
		  "void addEdge(int u, int v){",
		  " adj[u].push_back(v);",
		  " adj[v].push_back(u);",
		  "}",
		  "",
		  "int dist(int a, int b){",
		  " return level[a] + level[b] - 2 * level[LCA(a, b)];",
		  "}",
		  ""
		],
		"description": "LCA path satisfying some condition"
	},
	"arr-pref": {
		"prefix": "arr-pref",
		"body": [
		  "vector<int> pre(n, 0);",
		  "pre[0]=a[0];",
		  "for(int i=1;i<n;i++) pre[i]=a[i]+pref[i-1];"
		],
		"description": "arr-pref"
	},
	"modpow": {
		"prefix": "modpow",
		"body": [
		  "int modpow(int a, int b){",
		  "    a %= m;",
		  "    int res = 1;",
		  "    while (b > 0) {",
		  "        if (b & 1) res = res * a % m;",
		  "        a=a*a%m;",
		  "        b>>=1;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "modpow"
	},
	"mint    ============ SEE the usecase": {
		"prefix": "mint",
		"body": [
		  "struct mi {",
		  "    int64_t v; explicit operator int64_t() const { return v % mod; }",
		  "    mi() { v = 0; }",
		  "    mi(int64_t _v) {",
		  "        v = (-mod < _v && _v < mod) ? _v : _v % mod;",
		  "        if (v < 0) v += mod;",
		  "    }",
		  "    friend bool operator==(const mi& a, const mi& b) {",
		  "        return a.v == b.v; }",
		  "    friend bool operator!=(const mi& a, const mi& b) {",
		  "        return !(a == b); }",
		  "    friend bool operator<(const mi& a, const mi& b) {",
		  "        return a.v < b.v; }",
		  "",
		  "    mi& operator+=(const mi& m) {",
		  "        if ((v += m.v) >= mod) v -= mod;",
		  "        return *this; }",
		  "    mi& operator-=(const mi& m) {",
		  "        if ((v -= m.v) < 0) v += mod;",
		  "        return *this; }",
		  "    mi& operator*=(const mi& m) {",
		  "        v = v*m.v%mod; return *this; }",
		  "    mi& operator/=(const mi& m) { return (*this) *= inv(m); }",
		  "    friend mi pow(mi a, int64_t p) {",
		  "        mi ans = 1; assert(p >= 0);",
		  "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;",
		  "        return ans;",
		  "    }",
		  "    friend mi inv(const mi& a) { assert(a.v != 0);",
		  "        return pow(a,mod-2); }",
		  "",
		  "    mi operator-() const { return mi(-v); }",
		  "    mi& operator++() { return *this += 1; }",
		  "    mi& operator--() { return *this -= 1; }",
		  "    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }",
		  "    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }",
		  "    friend mi operator+(mi a, const mi& b) { return a += b; }",
		  "    friend mi operator-(mi a, const mi& b) { return a -= b; }",
		  "    friend mi operator*(mi a, const mi& b) { return a *= b; }",
		  "    friend mi operator/(mi a, const mi& b) { return a /= b; }",
		  "    friend ostream& operator<<(ostream& os, const mi& m) {",
		  "        os << m.v; return os;",
		  "    }",
		  "    friend istream& operator>>(istream& is, mi& m) {",
		  "        int64_t x; is >> x;",
		  "        m.v = x;",
		  "        return is;",
		  "    }",
		  "    friend void __print(const mi &x) {",
		  "        cerr << x.v;",
		  "    }",
		  "};",
		  ""
		],
		"description": "modular integer"
	  },
	  "sieve": {
		"prefix": "sieve",
		"body": [
		  "vector<bool> Prime;",
		  "vector<int> spf;",
		  "void sieve(int s = maxn) {",
		  "    Prime.resize(s + 1, 1);",
		  "    spf.resize(s + 1, s + 1);",
		  "    for(int i = 2 ; i <= s ; i++)   if(Prime[i]) {",
		  "        spf[i] = min(spf[i], i);",
		  "        for(int j = i ; j * i <= s ; j++)",
		  "            Prime[j * i] = 0, spf[j * i] = min(i, spf[j * i]);",
		  "    }",
		  "}",
		  ""
		],
		"description": "sieve"
	},
	"derangments ======+CHECK this later!": {
		"prefix": "derangments",
		"body": [
		  "int countDerangements(int n){",
		  "    int dp[n + 1];",
		  "    if (n < 3) return (dp[n]=(n % 2)?1:0);",
		  "    dp[0] = 1, dp[1] = 0, dp[2] = 1;",
		  "    for (int i=3; i< n; i++) dp[i] = (i-1)*(dp[i-1]+dp[i-2]);",
		  "    return dp[n];",
		  "}"
		],
		"description": "derangments"
	},
	"euclid =========GCD stuff": {
		"prefix": "euclid",
		"body": [
		  "int euclid_gcd(int a, int b){",
		  "    if (b==0) return a;",
		  "    return gcd(b, a % b);",
		  "}",
		  "",
		  "int euclid_gcdExtended(int a, int b, int *x, int *y){",
		  "    if (a == 0){",
		  "        *x = 0;",
		  "        *y = 1;",
		  "        return b;",
		  "    }",
		  "    int x1, y1;",
		  "    int gcd = gcdExtended(b % a, a, &x1, &y1);",
		  "    *x = y1 - (b / a) * x1;",
		  "    *y = x1;",
		  "    return gcd;",
		  "}",
		  "",
		  ""
		],
		"description": "euclid"
	},
	"easy_seive ============what's the difference?": {
		"prefix": "easy_seive",
		"body": [
		  "void ez_seive(int n){",
		  "     vector<bool> prime(n,1);",
		  "     for (int p = 2; p*p <= n; p++){",
		  "         if (prime[p]){",
		  "            for (int i = p * p; i <= n; i += p) prime[i] = false;",
		  "         }",
		  "     }",
		  "}",
		  "for (int p = 2; p <= n; p++){",
		  "      // do whatever you want with those primes${1}",
		  "      if (prime[p]) cout << p << \" \";",
		  "}",
		  ""
		],
		"description": "easy_seive"
	}
}

// use this AWESOME website - https://snippet-generator.app/ 